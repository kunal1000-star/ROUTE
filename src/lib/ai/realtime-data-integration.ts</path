// Real-time Data Integration Service
// ===================================

import { createClient } from '@supabase/supabase-js';
import { rateLimitTracker } from './rate-limit-tracker';
import { responseCache } from './response-cache';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export interface RealtimeEvent {
  type: 'provider_status' | 'usage_update' | 'cache_invalidate' | 'user_activity' | 'error_alert';
  timestamp: string;
  data: any;
  source: string;
}

export interface ProviderStatus {
  provider: string;
  status: 'online' | 'offline' | 'degraded';
  responseTime: number;
  lastCheck: string;
  errorRate: number;
  uptime: number;
  activeConnections: number;
}

export interface UsageMetrics {
  provider: string;
  requestsPerMinute: number;
  tokensPerMinute: number;
  costPerMinute: number;
  errorRate: number;
  averageLatency: number;
  timestamp: string;
}

export interface UserActivity {
  userId: string;
  action: string;
  timestamp: string;
  provider?: string;
  latency?: number;
  success: boolean;
}

export class RealtimeDataIntegration {
  private static instance: RealtimeDataIntegration;
  private eventHandlers: Map<string, ((event: RealtimeEvent) => void)[]> = new Map();
  private isConnected: boolean = false;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private usageHistory: Map<string, UsageMetrics[]> = new Map();
  private activeConnections: Map<string, number> = new Map();

  private constructor() {
    this.initializeEventSystem();
    this.startHeartbeat();
  }

  public static getInstance(): RealtimeDataIntegration {
    if (!RealtimeDataIntegration.instance) {
      RealtimeDataIntegration.instance = new RealtimeDataIntegration();
    }
    return RealtimeDataIntegration.instance;
  }

  /**
   * Initialize real-time event system
   */
  private initializeEventSystem(): void {
    console.log('ðŸ”„ Initializing Real-time Data Integration...');

    // Set up Supabase real-time subscriptions
    this.setupRealtimeSubscriptions();
    
    // Initialize provider monitoring
    this.startProviderMonitoring();
    
    // Initialize usage tracking
    this.startUsageTracking();
    
    // Initialize user activity monitoring
    this.startUserActivityMonitoring();
    
    this.isConnected = true;
    console.log('âœ… Real-time Data Integration initialized');
  }

  /**
   * Set up Supabase real-time subscriptions
   */
  private setupRealtimeSubscriptions(): void {
    // Subscribe to provider status changes (optional for now)
    try {
      supabase
        .channel('provider-status-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'provider_health_status'
          },
          (payload) => {
            this.handleProviderStatusChange(payload);
          }
        )
        .subscribe();

      // Subscribe to usage logs
      supabase
        .channel('usage-log-updates')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'api_usage_logs'
          },
          (payload) => {
            this.handleUsageUpdate(payload);
          }
        )
        .subscribe();
    } catch (error) {
      console.warn('Real-time subscriptions setup failed:', error);
    }
  }

  /**
   * Start provider health monitoring
   */
  private startProviderMonitoring(): void {
    const providers = ['groq', 'cohere', 'mistral', 'gemini', 'cerebras', 'openrouter'];
    
    setInterval(async () => {
      for (const provider of providers) {
        try {
          const healthStatus = await this.checkProviderHealth(provider);
          const event: RealtimeEvent = {
            type: 'provider_status',
            timestamp: new Date().toISOString(),
            data: {
              provider,
              status: healthStatus
            },
            source: 'health_monitor'
          };
          this.emitEvent(event);
        } catch (error) {
          console.warn(`Health check failed for ${provider}:`, error);
        }
      }
    }, 30000); // Check every 30 seconds
  }

  /**
   * Start usage tracking
   */
  private startUsageTracking(): void {
    setInterval(async () => {
      try {
        const usageData = await this.collectUsageMetrics();
        const event: RealtimeEvent = {
          type: 'usage_update',
          timestamp: new Date().toISOString(),
          data: usageData,
          source: 'usage_tracker'
        };
        this.emitEvent(event);
      } catch (error) {
        console.error('Usage tracking failed:', error);
      }
    }, 10000); // Collect every 10 seconds
  }

  /**
   * Start user activity monitoring
   */
  private startUserActivityMonitoring(): void {
    // Track active connections
    setInterval(() => {
      const activeConnections = this.getActiveConnectionCount();
      const event: RealtimeEvent = {
        type: 'user_activity',
        timestamp: new Date().toISOString(),
        data: {
          type: 'connection_update',
          activeConnections,
          topProviders: this.getTopProvidersByUsage()
        },
        source: 'activity_monitor'
      };
      this.emitEvent(event);
    }, 5000); // Update every 5 seconds
  }

  /**
   * Start heartbeat to maintain connection
   */
  private startHeartbeat(): void {
    this.heartbeatInterval = setInterval(() => {
      const heartbeatEvent: RealtimeEvent = {
        type: 'provider_status',
        timestamp: new Date().toISOString(),
        data: {
          type: 'heartbeat',
          status: 'alive',
          uptime: process.uptime(),
          memory: process.memoryUsage(),
          connections: this.activeConnections.size
        },
        source: 'heartbeat'
      };
      this.emitEvent(heartbeatEvent);
    }, 30000); // Heartbeat every 30 seconds
  }

  /**
   * Check provider health status
   */
  private async checkProviderHealth(provider: string): Promise<ProviderStatus> {
    try {
      const startTime = Date.now();
      
      // Use rate limit tracker to get provider status
      const statuses = rateLimitTracker.getAllStatuses();
      const status = statuses[provider] || { status: 'unknown', requestsTotal: 0, requestsFailed: 0 };
      const responseTime = Date.now() - startTime;
      
      return {
        provider,
        status: status.status === 'blocked' ? 'degraded' : 'online',
        responseTime,
        lastCheck: new Date().toISOString(),
        errorRate: status.requestsFailed / Math.max(status.requestsTotal, 1),
        uptime: this.calculateUptime(provider),
        activeConnections: this.activeConnections.get(provider) || 0
      };
    } catch (error) {
      return {
        provider,
        status: 'offline',
        responseTime: 0,
        lastCheck: new Date().toISOString(),
        errorRate: 1.0,
        uptime: 0,
        activeConnections: 0
      };
    }
  }

  /**
   * Collect usage metrics from database
   */
  private async collectUsageMetrics(): Promise<UsageMetrics[]> {
    const oneMinuteAgo = new Date(Date.now() - 60000).toISOString();
    
    const { data, error } = await supabase
      .from('api_usage_logs')
      .select('provider_used, success, latency_ms, cost_usd, tokens_input, tokens_output')
      .gte('timestamp', oneMinuteAgo);

    if (error) {
      console.error('Failed to collect usage metrics:', error);
      return [];
    }

    const metricsMap: Map<string, {
      requests: number;
      tokens: number;
      latency: number;
      costs: number;
      errors: number;
    }> = new Map();

    data?.forEach(log => {
      const provider = log.provider_used;
      if (!metricsMap.has(provider)) {
        metricsMap.set(provider, { requests: 0, tokens: 0, latency: 0, costs: 0, errors: 0 });
      }
      
      const stats = metricsMap.get(provider)!;
      stats.requests++;
      stats.tokens += log.tokens_input + log.tokens_output;
      stats.latency += log.latency_ms;
      stats.costs += log.cost_usd;
      if (!log.success) stats.errors++;
    });

    const metrics: UsageMetrics[] = [];
    for (const [provider, stats] of metricsMap) {
      metrics.push({
        provider,
        requestsPerMinute: stats.requests,
        tokensPerMinute: stats.tokens,
        costPerMinute: stats.costs,
        errorRate: stats.errors / stats.requests,
        averageLatency: stats.latency / stats.requests,
        timestamp: new Date().toISOString()
      });

      // Store in history for trend analysis
      if (!this.usageHistory.has(provider)) {
        this.usageHistory.set(provider, []);
      }
      const history = this.usageHistory.get(provider)!;
      history.push(metrics[metrics.length - 1]);
      
      // Keep only last 100 data points
      if (history.length > 100) {
        history.shift();
      }
    }

    return metrics;
  }

  /**
   * Handle provider status change events
   */
  private handleProviderStatusChange(payload: any): void {
    const event: RealtimeEvent = {
      type: 'provider_status',
      timestamp: new Date().toISOString(),
      data: {
        type: 'status_change',
        provider: payload.new?.provider || 'unknown',
        oldStatus: payload.old?.status,
        newStatus: payload.new?.status,
        reason: payload.new?.reason
      },
      source: 'database'
    };
    this.emitEvent(event);
  }

  /**
   * Handle usage update events
   */
  private handleUsageUpdate(payload: any): void {
    const event: RealtimeEvent = {
      type: 'usage_update',
      timestamp: new Date().toISOString(),
      data: {
        type: 'usage_event',
        provider: payload.new?.provider_used || 'unknown',
        success: payload.new?.success || false,
        latency: payload.new?.latency_ms || 0,
        cost: payload.new?.cost_usd || 0,
        tokens: (payload.new?.tokens_input || 0) + (payload.new?.tokens_output || 0)
      },
      source: 'database'
    };
    this.emitEvent(event);
  }

  /**
   * Register event handler
   */
  public on(eventType: string, handler: (event: RealtimeEvent) => void): void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType)!.push(handler);
  }

  /**
   * Unregister event handler
   */
  public off(eventType: string, handler: (event: RealtimeEvent) => void): void {
    const handlers = this.eventHandlers.get(eventType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  /**
   * Emit real-time event
   */
  private emitEvent(event: RealtimeEvent): void {
    const handlers = this.eventHandlers.get(event.type);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(event);
        } catch (error) {
          console.error('Event handler error:', error);
        }
      });
    }
  }

  /**
   * Track user activity
   */
  public trackUserActivity(activity: UserActivity): void {
    const event: RealtimeEvent = {
      type: 'user_activity',
      timestamp: new Date().toISOString(),
      data: activity,
      source: 'user_tracking'
    };
    this.emitEvent(event);
  }

  /**
   * Invalidate cache and broadcast event
   */
  public invalidateCache(cacheKey: string, reason: string = 'manual'): void {
    // Clear the cache entry (if method exists)
    if (typeof responseCache.clear === 'function') {
      responseCache.clear();
    }
    
    // Store cache event in database
    supabase
      .from('cache_events')
      .insert({
        key: cacheKey,
        reason,
        timestamp: new Date().toISOString()
      })
      .then(() => {
        const event: RealtimeEvent = {
          type: 'cache_invalidate',
          timestamp: new Date().toISOString(),
          data: {
            type: 'cache_invalidate',
            key: cacheKey,
            reason
          },
          source: 'manual'
        };
        this.emitEvent(event);
      })
      .catch((error: any) => {
        console.error('Failed to record cache event:', error);
      });
  }

  /**
   * Get active connection count
   */
  private getActiveConnectionCount(): number {
    return Array.from(this.activeConnections.values()).reduce((sum, count) => sum + count, 0);
  }

  /**
   * Get top providers by usage
   */
  private getTopProvidersByUsage(): Array<{ provider: string; usage: number }> {
    const usage = Array.from(this.usageHistory.entries()).map(([provider, history]) => {
      const recentUsage = history.slice(-10).reduce((sum, metrics) => sum + metrics.requestsPerMinute, 0);
      return { provider, usage: recentUsage };
    });
    
    return usage.sort((a, b) => b.usage - a.usage).slice(0, 5);
  }

  /**
   * Calculate provider uptime
   */
  private calculateUptime(provider: string): number {
    const recentUsage = this.usageHistory.get(provider);
    if (recentUsage && recentUsage.length > 0) {
      const avgRequests = recentUsage.slice(-10).reduce((sum, m) => sum + m.requestsPerMinute, 0) / 10;
      return avgRequests > 10 ? 99.5 : 95.0;
    }
    return 0;
  }

  /**
   * Get real-time dashboard data
   */
  public async getDashboardData(): Promise<{
    providers: ProviderStatus[];
    usage: UsageMetrics[];
    connections: number;
    lastUpdate: string;
  }> {
    const [providers, usage, connections, lastUpdate] = await Promise.all([
      this.getAllProviderStatuses(),
      this.getCurrentUsageMetrics(),
      Promise.resolve(this.getActiveConnectionCount()),
      Promise.resolve(new Date().toISOString())
    ]);

    return {
      providers,
      usage,
      connections,
      lastUpdate
    };
  }

  /**
   * Get all provider statuses
   */
  private async getAllProviderStatuses(): Promise<ProviderStatus[]> {
    const providers = ['groq', 'cohere', 'mistral', 'gemini', 'cerebras', 'openrouter'];
    const statuses: ProviderStatus[] = [];
    
    for (const provider of providers) {
      const status = await this.checkProviderHealth(provider);
      statuses.push(status);
    }
    
    return statuses;
  }

  /**
   * Get current usage metrics
   */
  private async getCurrentUsageMetrics(): Promise<UsageMetrics[]> {
    return this.collectUsageMetrics();
  }

  /**
   * Clean up resources
   */
  public destroy(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    this.eventHandlers.clear();
    this.isConnected = false;
    console.log('ðŸ›‘ Real-time Data Integration destroyed');
  }
}

// Export singleton instance
export const realtimeDataIntegration = RealtimeDataIntegration.getInstance();

// Auto-cleanup on process exit
process.on('SIGTERM', () => {
  realtimeDataIntegration.destroy();
});

process.on('SIGINT', () => {
  realtimeDataIntegration.destroy();
});
